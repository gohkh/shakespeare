import sys, argparse
import roman

TITLE = 'TITLE'
ACT, SCENE, ROMAN, LOCATION = 'ACT', 'SCENE', 'ROMAN', 'LOCATION'
CHARACTER, NUMBER, STRING, OPERATOR = 'CHARACTER', 'NUMBER', 'STRING', 'OPERATOR'
DIRECTION = 'DIRECTION'
TEXT = 'TEXT'
EOF = 'EOF'


class Token(object):
    def __init__(self, type, value):
        self.type = type
        self.value = value


class Interpreter(object):
    def __init__(self, file, _input):
        if file is None:
            self.text = _input
        else:
            with open(file,'r') as text:
                self.text = text.readlines()
        self.line = 0
        self.column = 0
        self.token = None
        if len(self.text) == 0:
            self.Line = None
            self.Char = None
        else:
            self.Line = self.text[self.line].split('#',1)[0]
            self.Char = self.Line[self.column]


    def ParseError(self):
        raise Exception('Unable to parse')

    def MissingTitleError(self):
        raise Exception('No title detected')

    def RomanNumeralError(self):
        raise Exception('Invalid roman numeral as ACT / SCENE number')

    def OrderError(self):
        if self.eat.token_type == ACT:
            raise Exception('SCENE before ACT')
        elif self.eat.token_type == ACT_NUM:
            raise Exception('ACT numbers not in running order')
        elif self.eat.token_type == SCENE_NUM:
            raise Exception('SCENE numbers not in running order')


    def advance_line(self):
        self.line += 1
        if self.line >= len(self.text):
            self.Line = None
        else:
            self.Line = self.text[self.line].split('#',1)[0]

    def advance_char(self):
        self.column += 1
        if self.Line is not None and self.column >= len(self.text[self.line]) - 2:
            self.Char = None
        else:
            self.Char = self.Line[self.column]

    def skip_whitespace(self):
        while self.Char is not None and self.Char.isspace():
            self.advance_char()


    def title(self):
        title = self.Line
        title = title.strip()
        return title

    def act(self):
        numeral = ''
        if self.Line[0:3] == ACT:
            for i in range(3):
                self.advance_char()
            self.skip_whitespace()
            while self.Char is not None:
                numeral = numeral + self.Char
                self.advance_char()
        return roman.roman(numeral)

    def scene(self):
        numeral = ''
        if self.Line[0:5] == SCENE:
            for i in range(5):
                self.advance_char()
            self.skip_whitespace()
            while self.Char is not None and self.Char != '.':
                numeral = numeral + self.Char
                self.advance_char()
        return roman.roman(numeral)


    def get_next_token(self):

        while self.Line is not None and self.Char is not None:
            self.Line = self.Line.replace('\n','')

            if self.Line.strip() == '':
                self.advance_line()
                continue

            if self.Line[0:3] == ACT:
                act = self.act()
                if act is not None:
                    token = Token(ACT, act)
                    self.advance_line()
                    return token
                else:
                    self.RomanNumeralError()

            if self.Line[0:5] == SCENE:
                scene = self.scene()
                if scene is not None:
                    token = Token(SCENE, scene)
                    self.advance_line()
                    return token
                else:
                    self.RomanNumeralError()

            if self.title() is not None:
                token = Token(TITLE, self.title())
                self.advance_line()
                return token

            self.ParseError()
        return Token(EOF, None)


    def eat(self, token_type):
        if self.token.type == token_type:
            self.token = self.get_next_token()
        elif token_type == TITLE:
            self.MissingTitleError()
        elif token_type == ACT:
            self.OrderError()


    def expr(self):
        act_list = []

        self.token = self.get_next_token()

        Title = self.token.value
        self.eat(TITLE)

        Act = self.token.value
        self.eat(ACT)
        act_list.append(Act)
        if act_list != list(range(Act+1)[1:]):
            self.OrderError()
        scene_list = []

        Scene = self.token.value
        self.eat(SCENE)
        scene_list.append(Scene)
        if scene_list != list(range(Scene+1)[1:]):
            self.OrderError()

        print('expr works')
        return Title, Act, Scene


def main(file):
    if file == None:
        while True:
            try:
                _input = []
                newline = input('>>> ')
                if newline == 'clear':
                    _input = []
                elif newline == 'exit':
                    sys.exit()
                else:
                    _input.append(newline + '\n')
            except EOFError:
                break
            if _input != []:
                interpret = Interpreter(file, _input)
    else:
        interpret = Interpreter(file, None)
    result = interpret.expr()
    print('yay')


def init():
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--file', type = str, default = None)
    args = parser.parse_args()

    main(args.file)

init()
